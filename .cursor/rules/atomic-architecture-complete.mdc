---
description: Atomic Architecture is a software design methodology that organizes components hierarchically (atoms, molecules, organisms, templates, pages), enabling development of complex applications through composition of reusable parts. It establishes clear data flow patterns, enforces consistent naming and directory structures, and improves maintainability by isolating components. This pattern works across frontend frameworks and can extend to backend services, promoting code reuse and development efficiency.
globs:
alwaysApply: false
---
# Atomic Architecture

This document provides comprehensive guidelines for implementing the Atomic Architecture pattern in your projects.

## 1. Core Structure

Atomic Architecture organizes components in increasing complexity:

### 1.1 Component Hierarchy

1. **Atoms**: Smallest UI elements, helpers, and utility functions
   - Basic inputs, buttons, icons, utility functions
   - Located in `src/atoms/` or `src/components/atoms/`
   - Self-contained with minimal dependencies

2. **Molecules**: Simple combinations of atoms
   - Form groups, search bars, card components
   - Located in `src/molecules/` or `src/components/molecules/`
   - May have state but limited business logic

3. **Organisms**: Complex UI sections
   - Navigation bars, dashboards, data tables
   - Located in `src/organisms/` or `src/components/organisms/`
   - Can contain internal state management

4. **Templates**: Page layouts without specific content
   - Located in `src/templates/` or `src/components/templates/`
   - Define structure but not content

5. **Pages**: Complete views with specific content
   - Located in `src/pages/` or equivalent
   - Compose templates with actual data

### 1.2 Directory Structure

```
src/
├── atoms/
│   ├── Button/
│   │   ├── Button.tsx
│   │   ├── Button.test.tsx
│   │   ├── Button.module.scss
│   │   └── index.ts
│   ├── Input/
│   │   └── ...
│   └── index.ts
├── molecules/
│   ├── SearchBar/
│   │   ├── SearchBar.tsx
│   │   └── ...
│   └── index.ts
├── organisms/
│   ├── NavBar/
│   │   └── ...
│   └── index.ts
└── templates/
    ├── DashboardTemplate/
    │   └── ...
    └── index.ts
```

## 2. Implementation Rules

### 2.1 Component Design

- Each component should have a single responsibility
- Components should use explicit props/parameters
- Prefer composition over inheritance
- Higher-level components should not reach into lower-level implementation details
- Use TypeScript interfaces to define component contracts
- Export each component from its directory's index file

### 2.2 Naming Conventions

- Component files: PascalCase.tsx (React) or PascalCase.vue (Vue)
- Utility files: camelCase.ts
- Test files: ComponentName.test.tsx
- Style files: ComponentName.module.css/scss

## 3. Component Composition

### 3.1 Composition Over Inheritance

```typescript
// Good - Composition
const Card = () => (
  <div className={styles.card}>
    <CardHeader />
    <CardBody>
      <CardContent />
    </CardBody>
    <CardFooter />
  </div>
);

// Avoid - Inheritance
class CustomCard extends BaseCard {
  render() {
    return <div>{super.render()}</div>;
  }
}
```

### 3.2 Prop Drilling

- Minimize by using context or state management for deeply nested components

## 4. Data Flow

### 4.1 Component Communication (Props Down, Events Up)

```
Page/Feature
   ↓ props     ↑ events
Template
   ↓ props     ↑ events
Organism
   ↓ props     ↑ events
Molecule
   ↓ props     ↑ events
Atom
```

- Pass data downward through props
- Communicate upward through events/callbacks
- Avoid prop drilling with context when appropriate

### 4.2 State Management Layers

#### Local Component State
- For UI-specific states (open/closed, focused, etc.)
- Use React's useState or equivalent
- Keep in the component where it's needed

#### Shared State
- For data needed by multiple components
- Options based on scope:
  - React Context for component trees
  - Redux/Zustand for application-wide state
  - Custom hooks for reusable logic

#### External Data
- Use data fetching libraries (React Query, SWR)
- Implement repository pattern for data access
- Create custom hooks for data access logic

## 5. Implementation Examples

### 5.1 Form Handling

```typescript
// Molecule: FormField
const FormField = ({ label, value, onChange }) => (
  <div>
    <Label>{label}</Label>
    <Input value={value} onChange={onChange} />
  </div>
);

// Organism: UserForm
const UserForm = ({ onSubmit, initialData }) => {
  const [user, setUser] = useState(initialData);

  const handleChange = (field) => (event) => {
    setUser({ ...user, [field]: event.target.value });
  };

  return (
    <Form onSubmit={() => onSubmit(user)}>
      <FormField
        label="Name"
        value={user.name}
        onChange={handleChange('name')}
      />
      <FormField
        label="Email"
        value={user.email}
        onChange={handleChange('email')}
      />
      <Button type="submit">Save</Button>
    </Form>
  );
};
```

### 5.2 Data Fetching

```typescript
// Custom hook (atom)
const useUserData = (userId) => {
  const { data, loading, error } = useFetch(`/api/users/${userId}`);
  return { user: data, loading, error };
};

// Organism: UserProfile
const UserProfile = ({ userId }) => {
  const { user, loading, error } = useUserData(userId);

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage message={error.message} />;

  return (
    <ProfileCard>
      <Avatar src={user.avatar} />
      <UserInfo name={user.name} email={user.email} />
      <UserStats stats={user.stats} />
    </ProfileCard>
  );
};
```

## 6. Best Practices

### 6.1 Testing Strategy

- **Atoms**: Focus on rendering and prop variations
- **Molecules**: Test component integration and simple interactions
- **Organisms**: Test complex interactions and state changes
- **Templates/Pages**: Focus on integration tests

### 6.2 Performance Considerations

- Memoize components when beneficial:
  ```typescript
  // Memoize atom components that render frequently
  const Button = React.memo(({ label, onClick }) => (
    <button onClick={onClick}>{label}</button>
  ));
  ```

- Use code splitting for larger organism and template components:
  ```typescript
  // Lazy load larger components
  const DashboardTemplate = React.lazy(() => import('./DashboardTemplate'));
  ```

### 6.3 Design System Integration

- Create a central design token system for colors, spacing, typography
- Reference design tokens in atomic components for consistency
- Document component usage with Storybook or similar tool

### 6.4 Accessibility

- Build accessibility into atoms and molecules
- Ensure all interactive elements are keyboard navigable
- Use ARIA attributes appropriately
- Test with screen readers
